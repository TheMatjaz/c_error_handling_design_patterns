% Copyright (c) 2018 Matjaž Guštin <dev@matjaz.it>
% All rights reserved.
% 
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
% 
% 1. Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright
%    notice, this list of conditions and the following disclaimer in the
%    documentation and/or other materials provided with the distribution.
% 3. Neither the name of the copyright holder nor the names of its
%    contributors may be used to endorse or promote products derived from
%    this software without specific prior written permission.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.

\documentclass[aspectratio=169,14pt]{beamer}
\input{preamble.tex}
\begin{document}

\begin{frame}
\titlepage

\begin{center}
    \begin{footnotesize}
    These slides are licensed under a \href{https://creativecommons.org/licenses/by/4.0/}{Creative~Commons~Attribution~4.0~International~License~(CC~BY~4.0)}.
    \end{footnotesize}
\end{center}
\end{frame}


\begin{frame}{Overview}
\begin{enumerate}
    \item A brief recap over Exceptions
    \item Return codes
    \item Other types of error indicators
\end{enumerate}

\begin{block}{Note}
It will be very code-based and development-focused
\end{block}
\end{frame}


\section{A brief recap over Exceptions}

\begin{frame}{Exceptions}
In OOP languages we commonly have the \textbf{Exception} classes used to handle:
\begin{itemize}
    \item unexpected values or states
    \item special cases
    \item non-nominal situations
    \item ... basically something that cannot be handled the normal way
\end{itemize}
\end{frame}


\begin{frame}{Control flow break}
When one Exception object is raised/thrown
\begin{itemize}
    \item it breaks the normal execution flow
    \item makes the current function return early
    \item repeats the same on every function in the stack towards the \texttt{main()}
    \item stops when caught with a \texttt{try-catch} block
    \item or makes the program terminate abruplty if nothing catches it
\end{itemize}
\end{frame}


\begin{frame}{Advantages of exceptions}
\begin{itemize}
    \item The biggest advantage of exceptions is the break of the control flow
    \item It allows separation of the nominal behaviour and the error handling behaviour
    \item It's nicer to read
\end{itemize}
\end{frame}


\begin{frame}{From \textit{Clean Code} by Robert C. Martin}
\begin{itemize}
    \item \textit{\quotes{Returning error codes from command functions is a subtle violation of command query separation.}}
    \item \textbf{Command query separation}: \textit{\quotes{functions should either do something or answer something, but not both. Either your function should change the state of an object [command], or it should return some information about that object [query]. Doing both often leads to confusion.}}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{}
\begin{lstlisting}[style=pythonstyle]
def update_software():
    completed = False
    while not completed:
        try:
            update = download_latest_software_update()
            update.check_integrity()
            update.install()
            completed = True
        except ConnectionError:
            log.error("Retrying download later.")
            time.sleep(3600)
        except IntegrityError:
            log.error("Downloaded file corrupted.")
        except InstallationError:
            log.error("No admin rights.")
            print("Please run the program with sudo.")
            completed = True
        finally:
            update.erase_temp_files()
\end{lstlisting}
\end{frame}


\begin{frame}{But...}
\begin{itemize}
    \item Many programming languages were created before OOP was even a thing
    \item Examples: Fortran, C, Cobol, Pascal or the more modern Rust
    \item Other patterns were found at the time and are still in use today
    \item The main difference is: \textbf{the control flow is not broken!} Manual handling is required.
    \item \textit{\quotes{If a tree falls in a forest and no one is around to hear it, does it make a sound?}}
\end{itemize}
\end{frame}

\begin{frame}{Problem and forces}
\begin{itemize}
    \item Need a way to indicate to the function caller that something could not be done and why.
    \item Exceptions are not available.
    \item Must be simple, lightweight, efficient, easy to understand.
\end{itemize}
\end{frame}

\begin{frame}{Overview of the patterns}
\begin{enumerate}
    \item Return codes
    \item Using the values' domain
    \item \texttt{<errno.h>} and global error codes
    \item \texttt{<jmp.h>}
    \item SQL and NULL
\end{enumerate}
\end{frame}


\section{Return codes}

\begin{frame}{Return codes}
\begin{itemize}
    \item The function's return value indicates its execution success or failure
    \item Different levels of detail in the output
    \item A potential way to categorize them\footnote{This is just my proposal, as often all these terms are used as synonyms}
    \begin{enumerate}
        \item Boolean codes
        \item Error codes
        \item Status/state codes
    \end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Boolean return code}
\begin{lstlisting}[style=cstyle]
#include <stdbool.h>

bool receive_message(message_t* message);

// Alternate version without booleans
int receive_message(message_t* message);
\end{lstlisting}

\begin{description}
    \item[\texttt{true}] (or non-0) on success
    \item[\texttt{false}] (or 0) on failure
\end{description}
\end{frame}


\begin{frame}[fragile]{Boolean return code: consequences}
\begin{itemize}
    \item Why did it fail?
    \item Can we retry or not?
    \item Can we tune the receving settings based on the error?
    \item Confusing: does \texttt{false} indicate \quotes{no error} or \quotes{no success}?
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Boolean return code: usage examples}
\begin{lstlisting}[style=cstyle]
message_t rx_message;
if (!receive_message(&rx_message)) {
    puts("Reception failure");
}
\end{lstlisting}

\begin{lstlisting}[style=cstyle]
message_t rx_message;
while (!receive_message(&rx_message)) {
    sleep(5);
}
\end{lstlisting}

Hard to remember if the negation is needed or not.
\end{frame}


\begin{frame}[fragile]{Error code}
\begin{lstlisting}[style=cstyle]
enum rx_code_t {
    RX_OK = 0,
    ERROR_TIMEOUT_NOTHING_RECEIVED,
    ERROR_BROKEN_CRC,
    ERROR_INCOMPLETE_MESSAGE,
    ERROR_ANTENNA_DISCONNECTED,
}

rx_code_t receive_message(message_t* message);
\end{lstlisting}

\begin{description}
    \item[\texttt{RX\_OK}] on success. OK is \texttt{false} to indicate the \textit{absence} of errors.
    \item[Others] on failure. The actual value indicates the exact reason.
\end{description}
\end{frame}


\begin{frame}[fragile]{Error code: consequences}
\begin{itemize}
    \item Cleaner setup
    \item We can handle different failure cases in different ways
    \item Easy to remember which value is the success: the \texttt{false} value
    \item Longer code handling the cases
    \item \textbf{Arguably the most common pattern!}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Usage examples: error code}
\begin{lstlisting}[style=cstyle]
message_t rx_message;
rx_code_t error;

error = receive_message(&rx_message);
if (error != RX_OK) {  // Simply: if (error) {...}
    puts("Reception failure");
}
\end{lstlisting}

\begin{lstlisting}[style=cstyle]
message_t rx_message;
rx_code_t rx_code;

if ((rx_code = receive_message(&rx_message)) != RX_OK) {
    puts("Reception failure");
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{}
\begin{lstlisting}[style=cstyle,basicstyle=\scriptsize\ttfamily]
message_t rx_message;
rx_code_t rx_code;
bool keep_receiving = true;

do {
    rx_code = receive_message(&rx_message);
    switch (rx_code) {
        case (RX_OK): {
            process_message(&rx_message);
            break;
        }
        case (ERROR_TIMEOUT_NOTHING_RECEIVED) {
            sleep(5);
            break;
        }
        case (ERROR_ANTENNA_DISCONNECTED) {
            puts("Please connect the antenna to the PC");
            keep_receiving = false;
            break;
        }
        default: {} // Do nothing, just retry the reception.
    }
} while (keep_receiving);
\end{lstlisting}
\end{frame}

\begin{frame}{Usage examples: process exit status}
\begin{itemize}
    \item Also known as \textit{exit code} or \textit{error level}.
    \item A value that a process running on an OS returns after its termination to the parent process.
    \item Usually \texttt{int32} where 0 means OK: process completed successfully.
    \item Meaning of the non-zero values (why the process failed) is not standardized: every OS has a different list of recommended/preferred interpretations.
    \item In C it's the \texttt{int} value returned by the \texttt{main} function. Alternatively the \texttt{exit()} function can be used to terminate the program at any point with the specified exit code to be returned.
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Status code}
\begin{lstlisting}[style=cstyle]
enum status_code_t {
    STATUS_OK_DETERMINISTIC = 0,
    STATUS_OK_PROBABILISTIC_HIGH_PROB,
    STATUS_OK_PROBABILISTIC_LOW_PROB,
    STATUS_ERROR_ILLEGAL_HEADER,
    STATUS_ERROR_ILLEGAL_CONTENT,
    STATUS_ERROR_ILLEGAL_ENCODING,
}
#define STATUS_IS_OK(s) ((s) == STATUS_OK_DETERMINISTIC || (s) == STATUS_OK_PROBABILISTIC_HIGH_PROB || (s) == STATUS_OK_PROBABILISTIC_LOW_PROB )

status_code_t process_message(message_t* message);
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Status code: consequences}
\begin{itemize}
    \item Multiple ways to complete a task (Strategy) and we known which one was chosen
    \item We can handle different success cases in different ways
    \item May be confusing
    \item Ofter macros are used to group \quotes{OK}-states, which results in a regular error code
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Cleaner setup}
\begin{lstlisting}[style=cstyle]
enum error_code_t {
    STATUS_OK = 0,
    STATUS_ERROR_ILLEGAL_HEADER,
    STATUS_ERROR_ILLEGAL_CONTENT,
    STATUS_ERROR_ILLEGAL_ENCODING,
}
enum status_extra_t {
    STATUS_EXTRA_DETERMINISTIC = 0,
    STATUS_EXTRA_PROBABILISTIC_HIGH_PROB,
    STATUS_EXTRA_PROBABILISTIC_LOW_PROB,
}

error_code_t process_message(message_t* message,
                             status_extra_t* extra);
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Cleaner setup: consequences}
\begin{itemize}
    \item Now we need to handle two values instead of one
    \item What is the value of \texttt{extra} if an error happens during processing?
    \item What happens if I pass a \texttt{NULL} pointer for \texttt{extra}?
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Nested return codes problem}
\begin{lstlisting}[style=cstyle]
rx_code_t receive_message(message_t* message) {
    rx_code_t reception_error = RX_OK;
    encoding_code_t encoding_error ENC_OK;
    
    encoding_error = prepare_message(message);
    if (encoding_error) {
        return ???;  // Which error code should we return?
    }
    ...
}
\end{lstlisting}
\end{frame}

\begin{frame}{Nested return codes problem (cont.)}
\begin{itemize}
    \item Returning the inner error code \texttt{encoding\_error} breaks abstraction layers
    \item Returning the outer error code \texttt{reception\_error} may hide details
    \item Expanding the outer error code enum to contain also encoding errors may need too many values
    \item Often one enum is used for a whole library with many values
    \item Combining the error code into a concatenated integer leads to confusion
\end{itemize}
\end{frame}


\section{A note on the code style}

\begin{frame}[fragile]{Stopping the execution flow with error codes}
\begin{lstlisting}[style=cstyle]
rx_code_t receive_message(message_t* message) {
    receiver_config_t config;  rx_code_t error_code;
    
    error_code = load_receiver_config_from_storage(&config);
    if (error_code) return error_code;  // Bad, missing brackets
    error_code = receiver_enable_peripheral();
    if (error_code) { return error_code; }  // Always use brackets
    error_code = receiver_configure(&config);
    if (error_code) { return error_code; }
    error_code = receiver_receive(message);
    return error_code;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{With \texttt{while(0)}}
\begin{lstlisting}[style=cstyle]
rx_code_t receive_message(message_t* message) {
    receiver_config_t config;  rx_code_t error_code;
    
    do {
        error_code = load_receiver_config_from_storage(&config);
        if (error_code) { break; }
        error_code = receiver_enable_peripheral();
        if (error_code) { break; }
        error_code = receiver_configure(&config);
        if (error_code) { break; }
        error_code = receiver_receive(message);
    } while (0);
    return error_code;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Loops inside \texttt{while(0)}}
\begin{lstlisting}[style=cstyle]
rx_code_t receive_message(message_t* message) {
    receiver_config_t config;  rx_code_t error_code;
    
    do {
        error_code = load_receiver_config_from_storage(&config);
        if (error_code) { break; }
        for (int i = 0; i < 10; i++) {
            // Activate 10 peripherals
            error_code = receiver_enable_peripheral(i);
            if (error_code) { break; }
            // The break exits the for loop, not the while(0)
        }
        error_code = receiver_configure(&config);
        if (error_code) { break; }
        error_code = receiver_receive(message);
    } while (0);
    return error_code;
}
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{With \texttt{goto}}
\begin{lstlisting}[style=cstyle]
rx_code_t receive_message(message_t* message) {
    receiver_config_t config;  rx_code_t error_code;
    
    error_code = load_receiver_config_from_storage(&config);
    if (error_code) { goto terminate; }
    for (int i = 0; i < 10; i++) {
        // Activate 10 peripherals
        error_code = receiver_enable_peripheral(i);
        if (error_code) { goto terminate; }
    }
    error_code = receiver_configure(&config);
    if (error_code) { goto terminate; }
    error_code = receiver_receive(message);
    
    terminate: {
        return error_code;
    }
}
\end{lstlisting}
\end{frame}

\begin{frame}{My personal rules for \texttt{goto}}
\begin{enumerate}
    \item Avoid it, if you can.
    \item Use only \textbf{one label per function} with a clear name:
        \begin{itemize}
            \item Good: \texttt{goto termination}, \texttt{goto error\_handling}
            \item Bad: \texttt{goto failure}  (Does it jump to a failing point or handles a failure?)
        \end{itemize}
    \item Only jump \textbf{downwards in the code} (i.e. skip some instruction, don’t cycle them). Better if only to the function's end (to the \texttt{return} call).
\end{enumerate}
\end{frame}

\begin{frame}{The biggest problem with return codes}
\begin{center}
Nobody forces the programmer to check them, as opposed to exceptions that break the flow.
\end{center}
\end{frame}

\section{Using the return value domain}
\begin{frame}[fragile]{Return values outside the domain}

\begin{itemize}
    \item The function returns a value, not a return code.
    \item The value has a limited domain.
    \item When out of bounds, indicates an error.
\end{itemize}

Example: writing formatted strings to a file.

\begin{lstlisting}[style=cstyle]
int fprintf ( FILE * stream, const char * format, ... );
\end{lstlisting}

Returns the number of characters written: 0 or more. \textbf{Negative on failure}. 
\end{frame}


\begin{frame}[fragile]{Return values inside the domain}
Also known as \textit{semipredicate problem}: how do I distinguish between a valid output and an error indicator?

Example: parsing a string for an integer value.

\begin{lstlisting}[style=cstyle]
long int strtol (const char* str, char** endptr, int base);
\end{lstlisting}

Returns the converted integer. If no valid conversion could be performed, returns 0.
\end{frame}

\begin{frame}[fragile]{Return values inside the domain (cont.)}
What happens if the input string contains a zero digit?

\begin{lstlisting}[style=cstyle]
strtol("12", NULL, 10); // returns 12

strtol("0", NULL, 10);  // returns 0

strtol("fdjkfnskxg", NULL, 10);  // returns 0 as well!
\end{lstlisting}

But: \texttt{strtol()} sets second parameter \texttt{endptr} to first char after the parsed number. On failed parsing \texttt{str == endptr}.
\end{frame}


\section{\texttt{errno.h}}

\begin{frame}[fragile]{errno.h}
A standard, glorified global error code.

\begin{lstlisting}[style=cstyle]
#include <stdio.h>
#include <errno.h>   // To access the integer `errno`
#include <string.h>  // To convert `errno` to a human-readable string with strerror()

int main() {
    printf("At startup = %s\n", strerror(errno));
    FILE* file = fopen("NON_existing_file.txt", "r");
    if (file == NULL) {
        printf("After fopen fails = %s\n", strerror(errno));
    } else {
        fclose(file);
    }
    return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{errno.h (cont.)}
Output on execution:

\begin{lstlisting}[style=nostyle]
$ gcc errno_example.c -o errno_example && ./errno_example
At startup = Undefined error: 0
After fopen fails = No such file or directory
\end{lstlisting}
\end{frame}


\section{Embedded error indicator in value}

\begin{frame}[fragile]{A simple pointer}
A pointer to something may be NULL (have the value 0) to indicate the broken link.
Otherwise it can be dereferenced.

\textit{*cough* segmentation faults *cough*}

\begin{lstlisting}[style=cstyle]
#include <stdio.h>
#include <stdint.h>

int main() {
    uint8_t* buffer = malloc(50);
    if (buffer != NULL) {
        puts("Malloc succeeded and I have a buffer");
    } else {
        puts("Malloc failed");
    }
    return 0;
}
\end{lstlisting}
\end{frame}

\begin{frame}{IEEE 754 floating-point values}

The IEEE encoding of the real numbers has embedded handling of special cases.

\begin{itemize}
    \item \( + \infty \)
    \begin{itemize}
        \item division by (positive) zero: \texttt{1.0/0.0}
        \item overflows: \texttt{pow(10.0, 500.0)}
        \item always bigger than any other value
        \item to check: \texttt{isinf(value) \&\& value > 0}
    \end{itemize}

    \item \( - \infty \)
    \begin{itemize}
        \item division of negative value by zero: \texttt{-1.0/0.0}
        \item or by negative zero: \texttt{1.0/-0.0}
        \item underflows: \texttt{pow(-10.0, 501.0)}
        \item always smaller than any other value
        \item to check: \texttt{isinf(value) \&\& value < 0}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{IEEE 754 floating-point values (cont.)}
\begin{itemize}
    \item \texttt{NaN} (Not a Number)
    \begin{itemize}
        \item invalid operations
        \begin{itemize}
            \item \texttt{0.0/0.0}
            \item \texttt{Infinity * 0.0}
            \item \texttt{sqrt(-1.0)}
        \end{itemize}
        \item propagating: operations on a \texttt{NaN} return \texttt{NaN}
        \item comparing with a \texttt{NaN} always returns \texttt{false}
        \item has a quiet (just returning) and signaling variant (FPU/floatlib indicates error to the system)
        \item it even has free bits to encode type of error (rare)
        \item to check: \texttt{isnan(value)}
    \end{itemize}
    \item combined check: \texttt{isfinite(value)} returns \texttt{true} when the value is not \texttt{NaN} or \( \pm \infty \)
\end{itemize}
\end{frame}



\section{Other error signaling systems}

\section{Conclusion}

\begin{frame}{Sources}
    \begin{itemize}
        \item \url{https://en.wikipedia.org/wiki/Exception_handling}
        \item \url{https://en.wikipedia.org/wiki/Exit_status}
        \item \url{http://www.cplusplus.com/reference/}
        \item \url{https://en.wikipedia.org/wiki/Floating-point_arithmetic\#Special_values}
        \item Robert C. Martin, \textit{Clean Code: A Handbook of Agile Software Craftsmanship}, ISBN-10: 9780132350884 
    \end{itemize}
    
    \begin{footnotesize}
        \begin{center}
            These slides are licensed under a \href{https://creativecommons.org/licenses/by/4.0/}{Creative~Commons~Attribution~4.0~International~License~(CC~BY~4.0)}
            
            and the source code is available at
            
            \url{https://github.com/TheMatjaz/c_error_handling_design_patterns}
        \end{center}    
    \end{footnotesize}
\end{frame}

\end{document}
