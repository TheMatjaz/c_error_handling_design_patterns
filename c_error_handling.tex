% Copyright (c) 2018 Matjaž Guštin <dev@matjaz.it>
% All rights reserved.
% 
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions are met:
% 
% 1. Redistributions of source code must retain the above copyright notice,
%    this list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright
%    notice, this list of conditions and the following disclaimer in the
%    documentation and/or other materials provided with the distribution.
% 3. Neither the name of the copyright holder nor the names of its
%    contributors may be used to endorse or promote products derived from
%    this software without specific prior written permission.
% 
% THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
% AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
% IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
% ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
% LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
% CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
% SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
% INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
% CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
% ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
% POSSIBILITY OF SUCH DAMAGE.

\documentclass[aspectratio=169,14pt]{beamer}
\input{preamble.tex}
\begin{document}

\begin{frame}
\titlepage
\end{frame}



\begin{frame}[label=material]{Material}
\begin{itemize}
    \item Slides available on \href{https://matjaz.it/slides/}{\textbf{matjaz.it/slides}} 
    \item Slides licensed under a 
    \href{https://creativecommons.org/licenses/by/4.0/}{Creative~Commons~Attribution~4.0~International~License~(CC~BY~4.0)}
    \item LaTeX source code available at
    \href{https://github.com/TheMatjaz/c_error_handling_design_patterns}{github.com/TheMatjaz/c\_error\_handling\_design\_patterns}
\end{itemize}
\end{frame}



\begin{frame}{Overview}
\begin{enumerate}
    \item A brief recap over Exceptions
    \item Return codes\\
    \begin{enumerate}
        \item Boolean codes
        \item Error codes
        \item Error flags
        \item Status/state codes
    \end{enumerate}
    \item Code design choices with return codes
    \item Using the return value's domain
    \item Embedded error indicator in data type
    \item \texttt{<errno.h>}
    \item \texttt{<setjmp.h>}
\end{enumerate}

\textbf{Note}: it will be very code-based and development-focused
\end{frame}





\section{A brief recap over Exceptions}

\begin{frame}{Exceptions}
In OOP languages we commonly have the \textbf{Exception} classes used to handle:
\begin{itemize}
    \item unexpected values or states
    \item special cases
    \item non-nominal situations
    \item ... something that cannot be handled the normal way
\end{itemize}
\end{frame}



\begin{frame}{Advantages of exceptions}
\begin{itemize}
    \item Biggest advantage: break of the control flow
    \item Allows separation of:\\
    \begin{itemize}
        \item nominal behaviour
        \item error-handling behaviour
    \end{itemize}
    \item Nicer to read
\end{itemize}
\end{frame}



\begin{frame}[fragile]{}
\begin{lstlisting}[style=pythonstyle]
def update_software():
    completed = False
    while not completed:
        try:
            update = download_latest_software_update()
            update.check_integrity()
            update.install()
            completed = True
        except ConnectionError:
            log.error("Retrying download later.")
            time.sleep(3600)
        except IntegrityError:
            log.error("Downloaded file corrupted.")
        except InstallationError:
            log.error("No admin rights.")
            print("Please run the program with sudo.")
            completed = True
        finally:
            update.erase_temp_files()
\end{lstlisting}
\end{frame}



\begin{frame}{But...}
\begin{itemize}
    \item Many programming languages were created before OOP was even a thing (duh...)
    \item Examples: Fortran, C, Cobol, ... or the more modern Rust
    \item Other patterns took place, still in use today
    \item Main difference: \textbf{the control flow is not broken!} Manual handling is required.
\end{itemize}
\end{frame}



\begin{frame}{Problem and forces}
\begin{itemize}
    \item Need a way to indicate to the function caller that something could not be done and why.
    \item Exceptions are not available.
    \item Must be simple, lightweight, efficient, easy to understand.
\end{itemize}
\end{frame}





\section{Return codes}

\begin{frame}{Return codes}
\begin{itemize}
    \item The function's return value indicates its execution success or failure
    \item Different levels of detail in the output
    \item A potential way to categorize them\footnote{This is just my proposal, as often all these terms are used interchangeably}\\
    \begin{enumerate}
        \item Boolean codes
        \item Error codes
        \item Error flags
        \item Status/state codes
    \end{enumerate}
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Boolean return code}
\begin{lstlisting}[style=cstyle]
#include <stdbool.h>

bool receive_message(message_t* message);

// Alternate version without booleans
int receive_message(message_t* message);
\end{lstlisting}

\begin{description}
    \item[\texttt{true}] (or non-0) on success
    \item[\texttt{false}] (or 0) on failure
\end{description}
\end{frame}



\begin{frame}[fragile]{Boolean return code: consequences}
\begin{itemize}
    \item[\bad] Why did it fail?
    \item[\bad] Can we retry or not? Maybe with different settings?
    \item[\bad] Confusing: does \texttt{false} indicate \quotes{no error} or \quotes{no success}?
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Error code}
\begin{lstlisting}[style=cstyle]
typedef enum {
    RX_OK = 0,
    ERROR_TIMEOUT_NOTHING_RECEIVED,
    ERROR_BROKEN_CRC,
    ERROR_INCOMPLETE_MESSAGE,
    ERROR_ANTENNA_DISCONNECTED,
} rx_code_t;

rx_code_t receive_message(message_t* message);
\end{lstlisting}

\begin{description}
    \item[\texttt{RX\_OK}] on success. OK is \texttt{false} to indicate the \textit{absence} of errors.
    \item[Others] on failure. The actual value indicates the exact reason.
\end{description}
\end{frame}



\begin{frame}[fragile]{Error code: consequences}
\begin{itemize}
    \item[\good] Cleaner setup
    \item[\good] We can handle different failure cases in different ways
    \item[\good] Easy to remember which value is the success: the \texttt{false} value
    \item[\good] \textbf{Arguably the most common pattern} outside of \texttt{libc}
    \item[\bad] Longer code handling the cases
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Usage examples: error code}
\begin{lstlisting}[style=cstyle]
message_t rx_message;
rx_code_t error;

error = receive_message(&rx_message);
if (error != RX_OK) {  // Simply: if (error) {...}
    puts("Reception failure");
}
\end{lstlisting}

\begin{lstlisting}[style=cstyle]
message_t rx_message;
rx_code_t rx_code;

if ((rx_code = receive_message(&rx_message)) != RX_OK) {
    puts("Reception failure");
}
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{}
\begin{lstlisting}[style=cstyle,basicstyle=\scriptsize\ttfamily]
message_t rx_message;
rx_code_t rx_code;
bool keep_receiving = true;

do {
    rx_code = receive_message(&rx_message);
    switch (rx_code) {
        case (RX_OK): {
            process_message(&rx_message);
            break;
        }
        case (ERROR_TIMEOUT_NOTHING_RECEIVED) {
            sleep(5);
            break;
        }
        case (ERROR_ANTENNA_DISCONNECTED) {
            puts("Please connect the antenna to the PC");
            keep_receiving = false;
            break;
        }
        default: {} // Do nothing, just retry the reception.
    }
} while (keep_receiving);
\end{lstlisting}
\end{frame}



\begin{frame}{Usage examples: process exit status}
\begin{itemize}
    \item Also known as \textit{exit code} or \textit{error level}.
    \item Value that a process returns after its termination to the parent process.
    \item Usually \texttt{int32} where 0 means OK: process completed successfully.
    \item Non-zero values are not standardized: every OS has a different list of recommended/preferred interpretations.
    \item In C: the \texttt{int} value returned by \texttt{main()}. Alternatively the argument of \texttt{exit()}.
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Error flags}
\begin{lstlisting}[style=cstyle]
typedef enum {
    // Bit flags, each value on different bit
    RX_OK = 0x00,
    ERROR_TIMEOUT_NOTHING_RECEIVED = 0x01,
    ERROR_BROKEN_CRC = 0x02,
    ERROR_INCOMPLETE_MESSAGE = 0x04,
    ERROR_ANTENNA_DISCONNECTED = 0x08,
} rx_flag_t;
typedef uint8_t rx_code_t;

rx_code_t receive_message(message_t* message);
\end{lstlisting}

\begin{description}
    \item[\texttt{RX\_OK}] on success. No flags or \texttt{false} to indicate the \textit{absence} of errors.
    \item[Any flag] on failure. Each bit expresses one reason. More than one reason possible \textbf{simultaneously}.
\end{description}
\end{frame}



\begin{frame}[fragile]{Error flags: consequences}
In addition to the consequences of Error codes:

\begin{itemize}
    \item[\good] Useful if multiple failures can happen simultaneously
    \item[\good] Can still be used if only one failure at the time
    \item[\good] Easy to remember which value is the success: the \texttt{false} value
    \item[\bad] \(N\) bits indicate only \(N\) errors. Error codes indicate \(2^N - 1\). Bigger integer types may be needed.
    \item[\bad] Even longer code handling the cases (e.g. a series of \texttt{if-if-if} but not \texttt{switch-case})
    \item[\bad] Macros are required to group same-category flags
\end{itemize}
\end{frame}





\section{Code design choices with return codes}

\begin{frame}[fragile]{Nested return codes problem}
\begin{lstlisting}[style=cstyle]
tx_code_t transmit_message(message_t* message) {
    tx_code_t tx_error = RX_OK;
    encoding_code_t encoding_error = ENC_OK;
    
    encoding_error = prepare_message(message);
    if (encoding_error) {
        return ???;  // Which error code should we return?
    }
    ...
}
\end{lstlisting}
\end{frame}



\begin{frame}{Nested return codes problem (cont.)}
\begin{itemize}
    \item Returning the inner error code \texttt{encoding\_error} breaks abstraction layers
    \item Returning the outer error code \texttt{tx\_error} may hide details
    \item Using only one \texttt{enum} for everything: very big enum?
    \item Combining the error code into a concatenated integer leads to confusion
\end{itemize}
\end{frame}



\begin{frame}{Nested return codes problem (cont.)}
Common solutions: break abstraction layers

\begin{itemize}
    \item Either one huge \texttt{enum} containing every possible error\\
    \begin{itemize}
        \item Each function inside the library uses the same error code data type
        \item Just returning it to the upper layer
    \end{itemize}
    \item Or combined error code\\
    \begin{itemize}
        \item Example: ISO/IEC 7816 for smart cards uses \texttt{uint16}
        \item High byte for category (where failed)
        \item Low byte for reason (what failed)
        \item 0x9000 = OK\\
        0x69xx = Something with the command\\
        0x6900 = Command not allowed\\
        0x6981 = Command not compatible with data structure
    \end{itemize}
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Stopping flow with multiple \texttt{return}}
\begin{lstlisting}[style=cstyle]
rx_code_t receive_message(message_t* message) {
    receiver_config_t config;  rx_code_t error_code;
    
    error_code = load_receiver_config_from_storage(&config);
    if (error_code) return error_code;  // Bad, missing brackets
    error_code = receiver_enable_peripheral();
    if (error_code) { return error_code; }  // Always use brackets
    error_code = receiver_configure(&config);
    if (error_code) { return error_code; }
    error_code = receiver_receive(message);
    return error_code;
}
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{With \texttt{do-while(0)} is nicer}
\begin{lstlisting}[style=cstyle]
rx_code_t receive_message(message_t* message) {
    receiver_config_t config;  rx_code_t error_code;
    
    do {
        error_code = load_receiver_config_from_storage(&config);
        if (error_code) { break; }
        error_code = receiver_enable_peripheral();
        if (error_code) { break; }
        error_code = receiver_configure(&config);
        if (error_code) { break; }
        error_code = receiver_receive(message);
    } while (0);
    return error_code;
}
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{Loops inside \texttt{do-while(0)} don't work}
\begin{lstlisting}[style=cstyle]
rx_code_t receive_message(message_t* message) {
    receiver_config_t config;  rx_code_t error_code;
    do {
        error_code = load_receiver_config_from_storage(&config);
        if (error_code) { break; }
        for (int i = 0; i < 10; i++) {
            // Activate 10 peripherals
            error_code = receiver_enable_peripheral(i);
            if (error_code) { break; }
            // The break exits the for loop, not the while(0)
        }
        error_code = receiver_configure(&config);
        if (error_code) { break; }
        error_code = receiver_receive(message);
    } while (0);
    return error_code;
}
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{With \texttt{goto} works always}
\begin{lstlisting}[style=cstyle]
rx_code_t receive_message(message_t* message) {
    receiver_config_t config;  rx_code_t error_code;
    error_code = load_receiver_config_from_storage(&config);
    if (error_code) { goto terminate; }
    for (int i = 0; i < 10; i++) {
        // Activate 10 peripherals
        error_code = receiver_enable_peripheral(i);
        if (error_code) { goto terminate; }
    }
    error_code = receiver_configure(&config);
    if (error_code) { goto terminate; }
    error_code = receiver_receive(message);
    
    terminate: {
        return error_code;
    }
}
\end{lstlisting}
\end{frame}



\begin{frame}{My personal rules for \texttt{goto}}
\begin{enumerate}
    \item Avoid it, if you can.
    \item Use only \textbf{one label per function} with a clear name:\\
        \begin{itemize}
            \item Good: \texttt{goto termination}, \texttt{goto error\_handling}
            \item Bad: \texttt{goto failure}  (Does it jump to a failing point or handles a failure?)
        \end{itemize}
    \item Only jump \textbf{downwards in the code} (i.e. skip some instruction, don’t cycle them). Better if only to the function's end (to the \texttt{return} call).
\end{enumerate}
\end{frame}



\begin{frame}{Comparing various "returning" styles}
\begin{itemize}
    \item Multiple \texttt{return}: clear when writing, confusing to read. Not allowed by certain industry standards (e.g. automotive).
    \item \texttt{do-while(0)} is clear for simple cases after getting used to it
    \item \texttt{goto} is clear only when used correctly and only for this kind of handling
\end{itemize}
\end{frame}



\section{Using the return value's domain}

\begin{frame}[fragile]{Return values outside the domain}

\begin{itemize}
    \item The function returns a value, not a return code.
    \item The value has a limited domain.
    \item When value out of bounds, indicates an error.
\end{itemize}

Example: writing formatted strings to a file.

\begin{lstlisting}[style=cstyle]
int fprintf ( FILE * stream, const char * format, ... );
\end{lstlisting}

Returns the amount of characters written: 0 or more.\\
\textbf{Negative on failure}. 
\end{frame}



\begin{frame}[fragile]{Outside the domain: consequences}
\begin{itemize}
    \item[\good] No need for additional enums
    \item[\good] Easy to understand if something is wrong (e.g. negative length does not make sense)
    \item[\bad] Easy to forget to check and use error value as a good result
    \item[\bad] Must read documentation of function in detail 
    \item[\bad] Not possible if no value outside the domain exists
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Return values inside the domain}
\begin{itemize}
    \item Also known as \textit{semipredicate problem}
    \item how do I distinguish between a valid output and an error indicator?
\end{itemize}

Example: parsing a string for an integer value.

\begin{lstlisting}[style=cstyle]
long int strtol (const char* str, char** endptr, int base);
\end{lstlisting}

Returns the converted integer.\\
If no valid conversion could be performed, \textbf{returns 0}.
\end{frame}



\begin{frame}[fragile]{Return values inside the domain (cont.)}
What happens if the input string contains a zero digit?

\begin{lstlisting}[style=cstyle]
strtol("12", NULL, 10); // returns 12

strtol("0", NULL, 10);  // returns 0

strtol("fdjkfnskxg", NULL, 10);  // returns 0 as well!
\end{lstlisting}

But: \texttt{strtol()} sets second parameter \texttt{endptr} to first char after the parsed number. On failed parsing \texttt{str == endptr}.
\end{frame}




\begin{frame}[fragile]{Inside the domain: consequences}
\begin{itemize}
    \item[\bad] Extremely confusing
    \item[\bad] Just never ever do that
\end{itemize}
\end{frame}




\section{Embedded error indicator in data type}

\begin{frame}{Nullable types}
The language's type system supports every value to be either \texttt{NULL}-like indicating missing data or a value.

\begin{itemize}
    \item In Python anything can be \texttt{None}
    \item In SQL anything can be \texttt{NULL}
    \item In Java non-primitives only (\texttt{int} no, \texttt{Integer} yes): \textit{Null object pattern}
    \item In C works only with pointers
\end{itemize}
\end{frame}



\begin{frame}[fragile]{A simple pointer}
A pointer to something may be \texttt{NULL} (have the value 0) to indicate the broken link. Otherwise it can be dereferenced.

\begin{lstlisting}[style=cstyle]
#include <stdio.h>
#include <stdint.h>

int main() {
    uint8_t* buffer = malloc(50);
    if (buffer != NULL) {
        puts("Malloc succeeded and I have a buffer");
    } else {
        puts("Malloc failed");
    }
    return 0;
}
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{A simple pointer: consequences}
\begin{itemize}
    \item[\good] Embedded in most programming languages
    \item[\good] Every programmer understands: cannot work on \texttt{NULL}
    \item[\good] No need for checking a separate error code
    \item[\bad] Very easy to forget to check and dereference \texttt{NULL} (auch!)
    \item[\bad] Dereferencing may be too slow
    \item[\meh] In embedded environments may be possible work due to missing \texttt{malloc()}
    \item[\meh] May make the code less readable (\texttt{int*} vs \texttt{int})
\end{itemize}
\end{frame}



\begin{frame}[fragile]{Option(al) types}
Polymorphic type representing a value that may or may not have meaning. Mostly functional languages.
\begin{itemize}
    \item In Rust: \texttt{enum Option<T> \{ None, Some(T) \}}
    \item In Haskell: \texttt{data Maybe a = Nothing | Just a}
    \item In C\#: \texttt{Nullable<T>} or \texttt{T?}
    \item In C: manually...
\begin{lstlisting}[style=cstyle]
struct optional_uint32 {
    uint8_t error_code;  // Indicate if the value makes sense
    uint32_t value;      // Actual value
};
\end{lstlisting}
\end{itemize}
\end{frame}



\begin{frame}{IEEE 754 floating-point values}
The IEEE encoding of the real numbers has embedded handling of special cases.

\begin{itemize}
    \item \( + \infty \)\\
    \begin{itemize}
        \item division by (positive) zero: \texttt{1.0/0.0}
        \item overflows: \texttt{pow(10.0, 500.0)}
        \item always bigger than any other value
        \item to check: \texttt{isinf(value) \&\& value > 0}
    \end{itemize}

    \item \( - \infty \)\\
    \begin{itemize}
        \item division of negative value by zero: \texttt{-1.0/0.0}
        \item or by negative zero: \texttt{1.0/-0.0}
        \item underflows: \texttt{pow(-10.0, 501.0)}
        \item always smaller than any other value
        \item to check: \texttt{isinf(value) \&\& value < 0}
    \end{itemize}
\end{itemize}
\end{frame}



\begin{frame}{IEEE 754 floating-point values (cont.)}
\begin{itemize}
    \item \texttt{NaN} (Not a Number)\\
    \begin{itemize}
        \item invalid operations
        \begin{itemize}
            \item \texttt{0.0/0.0}
            \item \texttt{Infinity * 0.0}
            \item \texttt{sqrt(-1.0)}
        \end{itemize}
        \item propagating: operations on a \texttt{NaN} return \texttt{NaN}
        \item comparing with a \texttt{NaN} always returns \texttt{false}
        \item has a quiet (just returning) and signaling variant (FPU/floatlib indicates error to the system)
        \item it even has free bits to encode type of error (rare)
        \item to check: \texttt{isnan(value)}
    \end{itemize}
    \item combined check: \texttt{isfinite(value)} returns \texttt{true} when the value is not \texttt{NaN} or \( \pm \infty \)
\end{itemize}
\end{frame}



\begin{frame}{IEEE 754 floating-point values: consequences}
\begin{itemize}
    \item[\good] IEEE standard since decades, really every computer supports it
    \item[\good] Hardware accelerated
    \item[\good] No need for pointer dereferencing or checking a separate error code
    \item[\bad] Easy to forget to check with \texttt{isfinite()}
\end{itemize}
\end{frame}





\section{\texttt{<errno.h>}}

\begin{frame}[fragile]{\texttt{<errno.h>}}
A standard, glorified global error code.

\begin{lstlisting}[style=cstyle]
#include <stdio.h>
#include <errno.h>   // To access the integer `errno`
#include <string.h>  // To convert `errno` to a human-readable string with strerror()

int main() {
    printf("At startup: value=%d, string=%s\n",
    errno, strerror(errno));
    FILE *file = fopen("NON_existing_file.txt", "r");
    if (file == NULL) {
        printf("After fopen fails: value=%d, string=%s\n",
        errno, strerror(errno));
    } else { fclose(file); }
    return 0;
}
\end{lstlisting}
\end{frame}



\begin{frame}{\texttt{<errno.h>}: consequences}
\begin{itemize}
    \item[\good] Part of C standard library
    \item[\bad] Easy to lose track who set the \texttt{errno} variable in nested code
    \item[\bad] Global variables are bad
\end{itemize}
\end{frame}





\section{\texttt{<setjmp.h>}}

\begin{frame}[fragile]{\texttt{<setjmp.h>}}
\begin{lstlisting}[style=cstyle]
int setjmp (jmp_buf env);
\end{lstlisting}
\begin{itemize}
    \item Fills \texttt{env} with the current state of the calling environment, so it can be restored later.
    \item Returns 0 on direct invocation (when state is saved).
    \item Otherwise returns the value (forcibly non-zero) passed by \texttt{longjmp()} (when state is restored).
\end{itemize}
\end{frame}



\begin{frame}[fragile]{\texttt{<setjmp.h>} (cont.)}
\begin{lstlisting}[style=cstyle]
void longjmp (jmp_buf env, int val);
\end{lstlisting}
\begin{itemize}
    \item Restores stored \texttt{env}.
    \item Transfers the control to the point where \texttt{setjmp()} was last used to fill the \texttt{env}.
    \item Makes \texttt{setjmp()} return \texttt{val}.
    \item This function never returns (jumping to \texttt{setjmp()} before that).
\end{itemize}
\end{frame}



\begin{frame}[fragile]{}
\begin{lstlisting}[style=cstyle]
#include <stdio.h>
#include <setjmp.h>

static jmp_buf state;
typedef enum {
    OK = 0,
    NEGATIVE_VALUE = 1,
    TOO_BIG_VALUE = 2,
} error_code_t;

int twice4(int value) {
    if (value < 0) {
        printf("(!) Negative value: %d\n", value);
        longjmp(state, NEGATIVE_VALUE); // Restore state, set code
    } else if (value > 100) {
        printf("(!) Too big value: %d\n", value);
        longjmp(state, TOO_BIG_VALUE);  // Restore state, set code
    } else { return 2 * value; }
}
\end{lstlisting}
\end{frame}



\begin{frame}[fragile]{}
\begin{lstlisting}[style=cstyle]
int twice3(int value) { return twice4(value); }
int twice2(int value) { return twice3(value); }
int twice(int value)  { return twice2(value); }

int main() {
    // Initially saves state and sets error_code to 0.
    // Jumped to using longjmp(state, new_value),
    // setting error_code to new_value.
    int error_code = setjmp(state);
    if (error_code == OK) {
        int input = -10;  // -10 or 1000 jumps to else branch
        int result = twice(input);
        printf("Twice of %d is %d\n", input, result);
    } else {
        printf("Error code %d\n", error_code);
    }
    return 0;
}
\end{lstlisting}
\end{frame}



\begin{frame}{\texttt{<setjmp.h>}: consequences}
\begin{itemize}
    \item[\good] Breaking control flow
    \item[\good] Good performance (avoiding functions return calls)
    \item[\good] A way to implement exception-like behaviour
    \item[\bad] Like \texttt{goto} but worse: may be \textbf{very} confusing
    \item[\bad] Often readability is more important than premature optimization
\end{itemize}
\end{frame}





\section{Conclusion}

\begin{frame}{Wrapping up}
\begin{itemize}
    \item If your programming language supports exceptions or nullable/option types: use them
    \item Otherwise go with return error codes or flags: 0 for OK, other values for error cases
    \item Write the error handling code with care, focus on \textbf{readability}
\end{itemize}
\end{frame}



\begin{frame}{Sources}
\begin{small}
    \begin{itemize}
        \item \url{http://www.cplusplus.com/reference/}
        \item \url{https://en.wikipedia.org/wiki/Exception_handling}
        \item \url{https://en.wikipedia.org/wiki/Exit_status}
        \item \url{https://en.wikipedia.org/wiki/Nullable_type}
        \item \url{https://en.wikipedia.org/wiki/Floating-point_arithmetic\#Special_values}
        \item Robert C. Martin, \textit{Clean Code: A Handbook of Agile Software Craftsmanship}, ISBN-10: 9780132350884 
    \end{itemize}
\end{small}
\end{frame}



\againframe{material}



\end{document}
